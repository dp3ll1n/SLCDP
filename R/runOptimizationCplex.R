#' Calculate the solution for the Quadratic Programming (QP) problem using Cplex optimization environment.
#'
#' It combines input matrices and constraints for solving the QP problem.
#' @param MX Predictor matrix. It can be M matrix in OLS or Jacobian matrix in the Gauss-Newton algorithm.
#' @param dX Response vector. It can be deltas vector OLS or endValues in the Gauss-Newton algorithm.
#' @param W1Inv Inverse of the estimated covariance matrix. If NULL it is set to the appropriate identity matrix.
#' @param constraints list containing the constraints as generated by setConstraints.
#' @param bvec=NULL values for the inequality constraints (rates >= bvec). If NULL, bvec is filled with 0s.
#' @return  QP solution.

#' @export
#' @examples
#' runOptimizationCplex(MX,dX,W1Inv=NULL,constraints,bvec=NULL)


runOptimizationCplex=function(MX,dX,W1Inv=NULL,constraints,bvec=NULL){
  if(is.null(W1Inv)){
    W1Inv= Matrix::Diagonal(nrow(MX), x = 1)
  }
  if(is.null(bvec)){
    bvec= rep(0, nrow(constraints$A))
  }
  
  Qmat = 2*t(MX)%*% W1Inv %*%MX;
  cvec = -2*(as.vector(t(dX)))%*%W1Inv%*%MX;
  cvec=as.matrix(cvec)
  Qmat=as.matrix(Qmat)
  a=Rcplex::Rcplex(cvec, 
           (-1*(constraints$A)), 
           bvec=bvec, 
           as.matrix(Matrix::forceSymmetric(Qmat)),
           lb = constraints$lb, 
           ub = constraints$ub,
           objsense = c("min"), 
           sense = "L", vtype = NULL, n = 1)$xopt
  return(a)  
}
